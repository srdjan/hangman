<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modern Hangman Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 2rem;
      min-height: 100vh;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      color: #2c3e50;
      margin: 0 0 0.5rem;
      font-size: 2.5rem;
    }

    .description {
      color: #666;
      max-width: 600px;
      line-height: 1.6;
      margin: 0 auto 2rem;
    }

    /* Custom component styling */
    hangman-game {
      width: 100%;
      max-width: 800px;
      --primary-color: #2c3e50;
      --secondary-color: #3498db;
      --success-color: #2ecc71;
      --danger-color: #e74c3c;
      --text-color: #34495e;
    }

    footer {
      margin-top: 3rem;
      color: #666;
      font-size: 0.9rem;
      text-align: center;
    }

    footer a {
      color: #3498db;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 2rem;
      }

      .description {
        font-size: 0.9rem;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Modern Hangman</h1>
    <p class="description">
      A modern implementation of the classic Hangman game using Web Components and SVG.
      Guess the web development-related words! Use either your keyboard or click the
      on-screen buttons to play.
    </p>
  </header>

  <!-- Hangman Web Component -->
  <hangman-game></hangman-game>

  <footer>
    <p>Made with ♥ using modern web technologies</p>
    <p>Customize colors using CSS variables: --primary-color, --secondary-color, --success-color</p>
  </footer>

  <!-- Web Component Code -->
  <template id="hangman-template">
    <style>
      :host {
        display: block;
        font-family: 'Segoe UI', system-ui;
        --transition-speed: 300ms;
        --transition-easing: cubic-bezier(0.25, 0.1, 0.25, 1);
        --hover-scale: 1.03;
      }

      .container {
        padding: 2rem;
        background: #f8f9fa;
        border-radius: 1rem;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        transition: transform var(--transition-speed) var(--transition-easing);
      }

      .hangman-display {
        position: relative;
        width: 300px;
        margin: 0 auto;
        transition: transform var(--transition-speed) var(--transition-easing);
      }

      svg {
        width: 100%;
        height: auto;
        transform-origin: center;
        transition: all var(--transition-speed) var(--transition-easing);
      }

      .hangman-part {
        stroke: var(--primary-color);
        stroke-width: 4;
        stroke-linecap: round;
        opacity: 0;
        transition: opacity 0.3s ease;
        transform-origin: center;
      }

      .visible {
        opacity: 1;
      }

      /* Enhanced SVG styling */
      .hangman-part.visible animate {
        begin: 0s !important;
      }

      /* Animation for game state transitions */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }

        50% {
          transform: scale(1.05);
        }

        100% {
          transform: scale(1);
        }
      }

      .win-animation {
        animation: pulse 0.5s var(--transition-easing);
      }

      /* Enhanced accessibility focus states */
      :focus-visible {
        outline: 3px solid var(--secondary-color);
        outline-offset: 3px;
      }

      .word-display {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin: 2rem 0;
        font-size: 2.5rem;
        letter-spacing: 0.5rem;
        color: var(--text-color);
        flex-wrap: wrap;
      }

      .letter {
        border-bottom: 4px solid var(--secondary-color);
        min-width: 1em;
        text-align: center;
        text-transform: uppercase;
      }

      .keyboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
        gap: 0.5rem;
        margin-top: 2rem;
        transition: filter var(--transition-speed) var(--transition-easing);
      }

      .game-over .keyboard {
        filter: blur(1px);
      }

      button {
        padding: 0.8rem;
        border: none;
        border-radius: 0.5rem;
        background: var(--secondary-color);
        color: white;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all var(--transition-speed) var(--transition-easing);
        position: relative;
        overflow: hidden;
      }

      /* Modern button effects */
      button::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: rgba(255, 255, 255, 0.1);
        transform: rotate(45deg);
        opacity: 0;
        transition: opacity var(--transition-speed) var(--transition-easing);
      }

      button:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
        opacity: 0.7;
        transform: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px) scale(var(--hover-scale));
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
      }

      button:active:not(:disabled) {
        transform: translateY(1px);
      }

      button:hover:not(:disabled)::after {
        opacity: 1;
      }

      .status {
        text-align: center;
        margin: 1rem 0;
        font-size: 1.2rem;
        color: var(--text-color);
        height: 1.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-speed) var(--transition-easing);
      }

      .status.win {
        color: var(--success-color);
        font-weight: bold;
        transform: scale(1.1);
      }

      .status.lose {
        color: var(--danger-color);
        font-weight: bold;
      }

      .restart {
        background: var(--success-color);
        grid-column: span 3;
        position: relative;
        z-index: 1;
      }

      /* Theme toggle button */
      .theme-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: 1px solid var(--primary-color);
        color: var(--primary-color);
        padding: 0.5rem;
        border-radius: 0.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-speed) var(--transition-easing);
      }

      .theme-toggle:hover {
        background: var(--primary-color);
        color: white;
      }

      @media (max-width: 600px) {
        .word-display {
          font-size: 1.5rem;
          letter-spacing: 0.3rem;
        }

        .keyboard {
          grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
        }

        button {
          padding: 0.5rem;
          font-size: 1rem;
        }
      }
    </style>

    <div class="container">
      <button class="theme-toggle" aria-label="Toggle theme">🌓</button>

      <div class="hangman-display">
        <!-- Enhanced Hangman SVG -->
        <svg class="hangman-figure" viewBox="0 0 200 200" aria-hidden="true">
          <!-- Enhanced Gallows -->
          <path d="M20 180h160M60 180l-20-140h120l-20 140" stroke="var(--primary-color)" stroke-width="4"
            stroke-linecap="round" stroke-linejoin="round" />
          <path d="M30 40h140" stroke="var(--primary-color)" stroke-width="4" stroke-linecap="round" />

          <!-- Hangman parts with animations -->
          <!-- Rope -->
          <path class="hangman-part" d="M100 40v30" stroke-dasharray="35" stroke-dashoffset="35">
            <animate attributeName="stroke-dashoffset" from="35" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>

          <!-- Head with face -->
          <g class="hangman-part">
            <circle cx="100" cy="70" r="15" />
            <!-- Sad face (appears when visible) -->
            <path d="M92 75c0 0 5 5 16 0" stroke="var(--danger-color)" stroke-width="2" stroke-linecap="round"
              transform="rotate(180 100 75)" />
            <!-- Eyes -->
            <circle cx="93" cy="65" r="2" fill="var(--danger-color)" />
            <circle cx="107" cy="65" r="2" fill="var(--danger-color)" />
          </g>

          <!-- Body -->
          <path class="hangman-part" d="M100 85v50" stroke-dasharray="50" stroke-dashoffset="50">
            <animate attributeName="stroke-dashoffset" from="50" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>

          <!-- Left Arm -->
          <path class="hangman-part" d="M100 95c-10 5-20 15-30 20" stroke-dasharray="40" stroke-dashoffset="40">
            <animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>

          <!-- Right Arm -->
          <path class="hangman-part" d="M100 95c10 5 20 15 30 20" stroke-dasharray="40" stroke-dashoffset="40">
            <animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>

          <!-- Left Leg -->
          <path class="hangman-part" d="M100 135c-8 8-17 17-25 25" stroke-dasharray="40" stroke-dashoffset="40">
            <animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>

          <!-- Right Leg -->
          <path class="hangman-part" d="M100 135c8 8 17 17 25 25" stroke-dasharray="40" stroke-dashoffset="40">
            <animate attributeName="stroke-dashoffset" from="40" to="0" dur="0.5s" begin="indefinite" fill="freeze" />
          </path>
        </svg>

        <!-- Enhanced Celebratory SVG (hidden by default) -->
        <svg class="celebrate-figure" viewBox="0 0 200 200" aria-hidden="true" style="display: none;">
          <!-- Background celebratory elements -->
          <g class="confetti">
            <!-- Stars and confetti elements with animations -->
            <circle cx="50" cy="50" r="3" fill="gold">
              <animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" />
            </circle>
            <circle cx="150" cy="60" r="4" fill="#FF6B6B">
              <animate attributeName="opacity" values="0;1;0" dur="1.5s" repeatCount="indefinite" />
            </circle>
            <path d="M70 40l5 5-5 5 5-5-5-5" stroke="#4ECDC4" stroke-width="2">
              <animate attributeName="opacity" values="0;1;0" dur="2.3s" repeatCount="indefinite" />
            </path>
            <path d="M130 30l5 5-5 5 5-5-5-5" stroke="#FF6B6B" stroke-width="2">
              <animate attributeName="opacity" values="0;1;0" dur="1.7s" repeatCount="indefinite" />
            </path>
            <path d="M40 120l5 5-5 5 5-5-5-5" stroke="#FFE66D" stroke-width="2">
              <animate attributeName="opacity" values="0;1;0" dur="2.1s" repeatCount="indefinite" />
            </path>
            <path d="M160 140l5 5-5 5 5-5-5-5" stroke="#4ECDC4" stroke-width="2">
              <animate attributeName="opacity" values="0;1;0" dur="1.9s" repeatCount="indefinite" />
            </path>
          </g>

          <!-- Animated stick figure with happy face -->
          <g>
            <!-- Head with happy face -->
            <circle cx="100" cy="70" r="15" stroke="var(--success-color)" stroke-width="4" fill="none" />
            <!-- Happy face -->
            <path d="M92 75c0 0 5 5 16 0" stroke="var(--success-color)" stroke-width="2" stroke-linecap="round" />
            <!-- Eyes -->
            <circle cx="93" cy="65" r="2" fill="var(--success-color)" />
            <circle cx="107" cy="65" r="2" fill="var(--success-color)" />
          </g>

          <!-- Animated body -->
          <path d="M100 85v50" stroke="var(--success-color)" stroke-width="4" stroke-linecap="round">
            <animate attributeName="transform" type="rotate" from="0 100 85" to="-5 100 85" dur="0.5s"
              repeatCount="indefinite" additive="sum" />
          </path>

          <!-- Arms raised and animated -->
          <path d="M100 95l-30 -20" stroke="var(--success-color)" stroke-width="4" stroke-linecap="round">
            <animate attributeName="d" values="M100 95l-30 -20;M100 95l-32 -22;M100 95l-30 -20" dur="1s"
              repeatCount="indefinite" />
          </path>
          <path d="M100 95l30 -20" stroke="var(--success-color)" stroke-width="4" stroke-linecap="round">
            <animate attributeName="d" values="M100 95l30 -20;M100 95l32 -22;M100 95l30 -20" dur="1s"
              repeatCount="indefinite" />
          </path>

          <!-- Legs doing a little dance -->
          <path d="M100 135l-25 25" stroke="var(--success-color)" stroke-width="4" stroke-linecap="round">
            <animate attributeName="d" values="M100 135l-25 25;M100 135l-28 25;M100 135l-25 25" dur="0.7s"
              repeatCount="indefinite" />
          </path>
          <path d="M100 135l25 25" stroke="var(--success-color)" stroke-width="4" stroke-linecap="round">
            <animate attributeName="d" values="M100 135l25 25;M100 135l28 25;M100 135l25 25" dur="0.7s"
              repeatCount="indefinite" />
          </path>
        </svg>
      </div>

      <div class="word-display" role="region" aria-live="polite"></div>
      <div class="status" role="alert"></div>
      <div class="keyboard" role="group" aria-label="Keyboard"></div>

      <!-- Difficulty selector -->
      <div class="difficulty-selector" style="text-align: center; margin-top: 1rem;">
        <label for="difficulty">Difficulty: </label>
        <select id="difficulty" aria-label="Select difficulty level">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>
    </div>
  </template>

  <script>
    /**
     * Modern Hangman Game Component
     * A web component implementing a visually-enhanced hangman game with animations
     * and theme capabilities
     */
    class HangmanGame extends HTMLElement {
      // Game state enums
      static GameState = {
        PLAYING: 'playing',
        WON: 'won',
        LOST: 'lost'
      };

      // Difficulty levels with corresponding word groups
      static DifficultyLevels = {
        easy: ['HTML', 'CSS', 'VUE', 'REACT', 'NODE'],
        medium: ['JAVASCRIPT', 'TYPESCRIPT', 'WEBCOMPONENT', 'FRAMEWORK', 'FRONTEND'],
        hard: ['ASYNCHRONOUS', 'OBSERVABLES', 'AUTHENTICATION', 'PROGRESSIVE', 'ARCHITECTURE']
      };

      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.appendChild(document.getElementById('hangman-template').content.cloneNode(true));

        // Initialize state as immutable properties
        this.state = {
          gameState: HangmanGame.GameState.PLAYING,
          difficulty: 'medium',
          maxWrong: 7, // Matches the number of SVG parts
          selectedWord: '',
          guessedLetters: new Set(),
          wrongGuesses: 0,
          darkMode: false,
        };

        // Cache DOM elements
        this.elements = {
          container: this.shadowRoot.querySelector('.container'),
          wordDisplay: this.shadowRoot.querySelector('.word-display'),
          keyboard: this.shadowRoot.querySelector('.keyboard'),
          status: this.shadowRoot.querySelector('.status'),
          hangmanParts: this.shadowRoot.querySelectorAll('.hangman-part'),
          hangmanFigure: this.shadowRoot.querySelector('.hangman-figure'),
          celebrateFigure: this.shadowRoot.querySelector('.celebrate-figure'),
          themeToggle: this.shadowRoot.querySelector('.theme-toggle'),
          difficultySelector: this.shadowRoot.querySelector('#difficulty')
        };
      }

      /**
       * Component lifecycle method - initialize the game when connected to DOM
       */
      connectedCallback() {
        this.initEventListeners();
        this.initGame();
        this.createKeyboard();
      }

      /**
       * Component lifecycle method - clean up event listeners
       */
      disconnectedCallback() {
        document.removeEventListener('keydown', this.handleKeyPress);
      }

      /**
       * Initialize all event listeners using named functions
       * for better memory management
       */
      initEventListeners() {
        // Use bound methods for event handlers
        this.handleKeyPress = this.handleKeyPress.bind(this);
        this.handleButtonClick = this.handleButtonClick.bind(this);
        this.handleDifficultyChange = this.handleDifficultyChange.bind(this);
        this.toggleTheme = this.toggleTheme.bind(this);

        // Add event listeners
        this.shadowRoot.addEventListener('click', this.handleButtonClick);
        document.addEventListener('keydown', this.handleKeyPress);
        this.elements.difficultySelector.addEventListener('change', this.handleDifficultyChange);
        this.elements.themeToggle.addEventListener('click', this.toggleTheme);
      }

      /**
       * Initialize game state
       * @param {string} [difficulty] - Optional difficulty level
       */
      initGame(difficulty = this.state.difficulty) {
        const words = HangmanGame.DifficultyLevels[difficulty];
        const selectedWord = words[Math.floor(Math.random() * words.length)];

        // Update state immutably
        this.state = {
          ...this.state,
          gameState: HangmanGame.GameState.PLAYING,
          difficulty,
          selectedWord,
          guessedLetters: new Set(),
          wrongGuesses: 0
        };

        // Reset UI elements
        this.elements.container.classList.remove('game-over');
        this.elements.status.classList.remove('win', 'lose');
        this.elements.hangmanParts.forEach(part => part.classList.remove('visible'));
        this.elements.hangmanFigure.style.display = 'block';
        this.elements.celebrateFigure.style.display = 'none';
        this.elements.status.textContent = 'Guess the word!';

        // Update the display and enable keyboard
        this.updateDisplay();
        this.enableKeyboard(true);
      }

      /**
       * Create virtual keyboard
       */
      createKeyboard() {
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        this.elements.keyboard.innerHTML = [
          ...letters.split('').map(letter => `
            <button data-letter="${letter}" aria-label="${letter}">${letter}</button>
          `.trim()),
          `<button class="restart" aria-label="New Game">New Game</button>`
        ].join('');
      }

      /**
       * Update the game display based on current state
       */
      updateDisplay() {
        // Update word display with current guessed letters
        this.elements.wordDisplay.innerHTML = this.state.selectedWord
          .split('')
          .map(letter => `
            <span class="letter" aria-hidden="true">
              ${this.state.guessedLetters.has(letter) ? letter : ''}
            </span>
          `.trim()).join('');

        // Update hangman parts visibility with animations
        this.elements.hangmanParts.forEach((part, index) => {
          const shouldBeVisible = index < this.state.wrongGuesses;

          // Only add transition when becoming visible
          if (shouldBeVisible && !part.classList.contains('visible')) {
            // Add visible class to show the part
            part.classList.add('visible');

            // Restart animations
            const animations = part.querySelectorAll('animate');
            animations.forEach(anim => {
              anim.setAttribute('begin', '0s');
            });
          } else if (!shouldBeVisible) {
            part.classList.remove('visible');
          }
        });

        this.checkGameState();
      }

      /**
       * Handle button clicks within the component
       * @param {Event} e - Click event
       */
      handleButtonClick(e) {
        if (e.target.dataset.letter) {
          this.handleGuess(e.target.dataset.letter);
          e.target.disabled = true;
        } else if (e.target.classList.contains('restart')) {
          this.initGame();
        }
      }

      /**
       * Handle keyboard input events
       * @param {KeyboardEvent} e - Keyboard event
       */
      handleKeyPress(e) {
        if (!e.key.match(/^[a-z]$/i)) return;
        const letter = e.key.toUpperCase();
        const button = [...this.elements.keyboard.querySelectorAll('button')]
          .find(btn => btn.dataset.letter === letter);
        if (button && !button.disabled) {
          this.handleGuess(letter);
          button.disabled = true;
        }
      }

      /**
       * Handle difficulty changes
       * @param {Event} e - Change event
       */
      handleDifficultyChange(e) {
        this.initGame(e.target.value);
      }

      /**
       * Toggle between light and dark themes
       */
      toggleTheme() {
        // Toggle dark mode state
        this.state = {
          ...this.state,
          darkMode: !this.state.darkMode
        };

        // Apply theme classes
        if (this.state.darkMode) {
          this.elements.container.style.setProperty('--primary-color', '#f8f9fa');
          this.elements.container.style.setProperty('--text-color', '#f8f9fa');
          this.elements.container.style.background = '#2c3e50';
          this.elements.themeToggle.textContent = '☀️';
        } else {
          this.elements.container.style.setProperty('--primary-color', '#2c3e50');
          this.elements.container.style.setProperty('--text-color', '#34495e');
          this.elements.container.style.background = '#f8f9fa';
          this.elements.themeToggle.textContent = '🌓';
        }
      }

      /**
       * Process a letter guess
       * @param {string} letter - The guessed letter
       */
      handleGuess(letter) {
        // Don't process if the game is over or letter was already guessed
        if (this.state.gameState !== HangmanGame.GameState.PLAYING ||
          this.state.guessedLetters.has(letter)) {
          return;
        }

        // Create new state with the updated guessed letters
        const newGuessedLetters = new Set(this.state.guessedLetters);
        newGuessedLetters.add(letter);

        // Update state immutably
        this.state = {
          ...this.state,
          guessedLetters: newGuessedLetters,
          wrongGuesses: !this.state.selectedWord.includes(letter)
            ? this.state.wrongGuesses + 1
            : this.state.wrongGuesses
        };

        this.updateDisplay();
      }

      /**
       * Check if the game is won or lost
       */
      checkGameState() {
        const wordGuessed = [...this.state.selectedWord].every(l => this.state.guessedLetters.has(l));

        if (wordGuessed && this.state.gameState !== HangmanGame.GameState.WON) {
          // Update state for win
          this.state = {
            ...this.state,
            gameState: HangmanGame.GameState.WON
          };

          // Show victory SVG
          this.elements.hangmanFigure.style.display = 'none';
          this.elements.celebrateFigure.style.display = 'block';

          // Update UI for win state
          this.elements.status.textContent = `🎉 You won! The word was ${this.state.selectedWord}.`;
          this.elements.status.classList.add('win');
          this.elements.wordDisplay.classList.add('win-animation');

          // Disable keyboard
          this.enableKeyboard(false);

        } else if (this.state.wrongGuesses >= this.state.maxWrong &&
          this.state.gameState !== HangmanGame.GameState.LOST) {
          // Update state for loss
          this.state = {
            ...this.state,
            gameState: HangmanGame.GameState.LOST
          };

          // Ensure hangman figure is visible
          this.elements.hangmanFigure.style.display = 'block';
          this.elements.celebrateFigure.style.display = 'none';

          // Update UI for loss state
          this.elements.status.textContent = `Game Over! The word was ${this.state.selectedWord}.`;
          this.elements.status.classList.add('lose');
          this.elements.container.classList.add('game-over');

          // Disable keyboard
          this.enableKeyboard(false);
        }
      }

      /**
       * Enable or disable all letter buttons
       * @param {boolean} state - Whether buttons should be enabled
       */
      enableKeyboard(state) {
        this.elements.keyboard.querySelectorAll('[data-letter]').forEach(btn => {
          btn.disabled = !state;
        });
      }
    }

    // Register the component with the browser
    customElements.define('hangman-game', HangmanGame);

    // Feature detection for browser compatibility
    if (!window.customElements) {
      document.body.innerHTML = '<h1>Your browser needs to support Custom Elements to play this game.</h1>';
    }
  </script>
</body>

</html>